<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>esnext/lib/task.js - TaskGroup API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://localhost:8000/web/logo.svg" title="TaskGroup API"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 5.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/BaseInterface.html">BaseInterface</a></li>
                                <li><a href="../classes/Task.html">Task</a></li>
                                <li><a href="../classes/TaskGroup.html">TaskGroup</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: esnext/lib/task.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
// Imports
const BaseInterface = require(&#x27;./interface&#x27;)
const {copyObject, iterateObject, queue, wait, domain} = require(&#x27;./util&#x27;)
const ambi = require(&#x27;ambi&#x27;)

/**
Our Task Class

Available configuration is documented in {{#crossLink &quot;Task/setConfig&quot;}}{{/crossLink}}.

Available events:

- &#x60;started()&#x60; - emitted when we start execution
- &#x60;running()&#x60; - emitted when the method starts execution
- &#x60;failed(error)&#x60; - emitted when execution exited with a failure
- &#x60;passed()&#x60; - emitted when execution exited with a success
- &#x60;completed(error, ...resultArguments)&#x60; - emitted when execution exited, &#x60;resultArguments&#x60; are the result arguments from the method
- &#x60;error(error)&#x60; - emtited if an unexpected error occurs without ourself
- &#x60;done(error, ...resultArguments)&#x60; - emitted when either execution completes (the &#x60;completed&#x60; event) or when an unexpected error occurs (the &#x60;error&#x60; event)

Available internal statuses:

- &#x60;null&#x60; - execution has not yet started
- &#x60;&#x27;started&#x27;&#x60; - execution has begun
- &#x60;&#x27;running&#x27;&#x60; - execution of our method has begun
- &#x60;&#x27;failed&#x27;&#x60; - execution of our method has failed
- &#x60;&#x27;passed&#x27;&#x60; - execution of our method has succeeded
- &#x60;&#x27;destroyed&#x27;&#x60; - we&#x27;ve been destroyed and can no longer execute

Example:

&#x60;&#x60;&#x60; javascript
var Task = require(&#x27;taskgroup&#x27;).Task
var task

task = new Task(&#x27;my synchronous task&#x27;, function(){
    return 5
}).done(console.info).run()  // [null, 5]

task = new Task(&#x27;my asynchronous task&#x27;, function(complete){
    complete(null, 5)
}).done(console.info).run()  // [null, 5]

task = new Task(&#x27;my task that returns an error&#x27;, function(){
    var error = new Error(&#x27;deliberate error&#x27;)
    return error
}).done(console.info).run()  // [Error(&#x27;deliberator error&#x27;)]

task = new Task(&#x27;my task that passes an error&#x27;, function(complete){
    var error = new Error(&#x27;deliberate error&#x27;)
    complete(error)
}).done(console.info).run()  // [Error(&#x27;deliberator error&#x27;)]
&#x60;&#x60;&#x60;

@class Task
@extends BaseInterface
@constructor
@public
*/
export default class Task extends BaseInterface {
    /**
    The type of our class.

    Used for the purpose of duck typing
    which is needed when working with node virtual machines
    as instanceof will not work in those environments.

    @type String
    @property type
    @default &#x27;task&#x27;
    @private
    */
    get type () { return &#x27;task&#x27; }

    /**
    A helper method to check if the passed argument is an instanceof a {Task}.
    @param {Task} item - The possible instance of the {Task} that we want to check
    @return {Boolean} Whether or not the item is a {Task} instance.
    @method isTask
    @static
    @public
    */
    static isTask (item) {
        return (item &amp;&amp; item.type === &#x27;task&#x27;) || (item instanceof this)
    }

    /**
    Have we started execution yet?
    @type Boolean
    @property started
    @private
    */
    get started () {
        return this.state.status != null
    }

    /**
    Have we finished its execution yet?
    @type Boolean
    @property exited
    @private
    */
    get exited () {
        switch ( this.state.status ) {
            case &#x27;completed&#x27;:
            case &#x27;destroyed&#x27;:
                return true

            default:
                return false
        }
    }

    /**
    Have we been destroyed?
    @type Boolean
    @property destroyed
    @private
    */
    get destroyed () {
        return this.state.status === &#x27;destroyed&#x27;
    }

    /**
    Have we completed its execution yet?
    @type Boolean
    @property completed
    @private
    */
    get completed () {
        switch ( this.state.status ) {
            case &#x27;failed&#x27;:
            case &#x27;passed&#x27;:
            case &#x27;destroyed&#x27;:
                return true

            default:
                return false
        }
    }

    // -----------------------------------
    // @TODO Decide if the following is still needed

    /**
    The first {Error} that has occured.
    @type Error
    @property error
    @protected
    */
    get error () { return this.state.error }

    /**
    A {String} containing our current status. See our {Task} description for available values.
    @type String
    @property status
    @protected
    */
    get status () { return this.state.status }

    /**
    An {Array} of the events that we may emit. Events that will be executed can be found in the {Task} description.
    @type Array
    @property events
    @default [&#x27;events&#x27;, &#x27;error&#x27;, &#x27;started&#x27;, &#x27;running&#x27;, &#x27;failed&#x27;, &#x27;passed&#x27;, &#x27;completed&#x27;, &#x27;done&#x27;, &#x27;destroyed&#x27;]
    @protected
    */
    get events () { return this.state.events }

    /**
    An {Array} representing the returned result or the passed {Arguments} of our method.
    The first item in the array should be the {Error} if it exists.
    @type Array
    @property result
    @protected
    */
    get result () { return this.state.result }

    /**
    The {Domain} that we create to capture errors for our method.
    @type Domain
    @property taskDomain
    @protected
    */
    get taskDomain () { return this.state.taskDomain }

    /**
    Initialize our new {Task} instance. Forwards arguments onto {{#crossLink &quot;Task/setConfig&quot;}}{{/crossLink}}.
    @method constructor
    @public
    */
    constructor (...args) {
        // Initialise BaseInterface
        super()

        // State defaults
        this.state = {
            name: &#x60;${this.type} ${Math.random()}&#x60;,
            error: null,
            status: null,
            events: [&#x27;events&#x27;, &#x27;error&#x27;, &#x27;started&#x27;, &#x27;running&#x27;, &#x27;failed&#x27;, &#x27;passed&#x27;, &#x27;completed&#x27;, &#x27;done&#x27;, &#x27;destroyed&#x27;]
        }

        // Configuration defaults
        this.config = {
            run: false,
            onError: &#x27;exit&#x27;,
            ambi: true,
            domain: true,
            sync: false,
            args: null
        }

        // Apply user configuration
        this.setConfig(...args)
    }

    /**
    Set the configuration for our instance.

    @param {Object} [config]

    @param {String} [config.name] - What we would like our name to be, useful for debugging.
    @param {Function} [config.done] - Passed to {{#crossLink &quot;Task/onceDone&quot;}}{{/crossLink}} (aliases are &#x60;onceDone&#x60;, and &#x60;next&#x60;)
    @param {Function} [config.whenDone] - Passed to {{#crossLink &quot;Task/whenDone&quot;}}{{/crossLink}}
    @param {Object} [config.on] - A map of event names linking to listener functions that we would like bounded via {EventEmitter.on}.
    @param {Object} [config.once] - A map of event names linking to listener functions that we would like bounded via {EventEmitter.once}.
    @param {TaskGroup} [config.parent] - A parent {{#crossLink &quot;TaskGroup&quot;}}{{/crossLink}} that we may be attached to.
    @param {String} [config.onError] - Either &#x60;&#x27;exit&#x27;&#x60; or &#x60;&#x27;ignore&#x27;&#x60;, when &#x60;&#x27;ignore&#x27;&#x60; duplicate run errors are not reported, useful when combined with the timeout option.
    @param {Boolean} [config.sync=false] - Whether or not we should execute certain calls asynchronously (set to &#x60;false&#x60;) or synchronously (set to &#x60;true&#x60;).

    @param {Function} [config.method] - The {Function} to execute for our {Task}.
    @param {Array} [config.args] - Arguments that we would like to forward onto our method when we execute it.
    @param {Number} [config.timeout] - Millesconds that we would like to wait before timing out the method.
    @param {Boolean} [config.ambi=true] - Whether or not to use bevry/ambi to determine if the method is asynchronous or synchronous and execute it appropriately.
    @param {Boolean} [config.domain=true] - Whether or not to wrap the task execution in a domain to attempt to catch background errors (aka errors that are occuring in other ticks than the initial execution).

    @chainable
    @method setConfig
    @public
    */
    setConfig (...args) {
        const opts = {}

        // Extract the configuration from the arguments
        args.forEach(function (arg) {
            if ( arg == null )  return
            const type = typeof arg
            switch ( type ) {
                case &#x27;string&#x27;:
                    opts.name = arg
                    break
                case &#x27;function&#x27;:
                    opts.method = arg
                    break
                case &#x27;object&#x27;:
                    copyObject(opts, arg)
                    break
                default:
                    const error = new Error(&#x60;Unknown argument type of [${type}] given to Task::setConfig()&#x60;)
                    throw error
            }
        })

        // Apply the configuration directly to our instance
        iterateObject(opts, (value, key) =&gt; {
            if ( value == null )  return
            switch ( key ) {
                case &#x27;on&#x27;:
                    iterateObject(value, (value, key) =&gt; {
                        if ( value ) this.on(key, value)
                    })
                    break

                case &#x27;once&#x27;:
                    iterateObject(value, (value, key) =&gt; {
                        if ( value ) this.once(key, value)
                    })
                    break

                case &#x27;whenDone&#x27;:
                    this.whenDone(value)
                    break

                case &#x27;onceDone&#x27;:
                case &#x27;done&#x27;:
                case &#x27;next&#x27;:
                    this.onceDone(value)
                    break

                default:
                    this.config[key] = value
                    break
            }
        })

        // Chain
        return this
    }

    /**
    What to do when our task method completes.
    Should only ever execute once, if it executes more than once, then we error.
    @param {Arguments} args - The arguments that will be applied to the {::result} variable. First argument is the {Error} if it exists.
    @chainable
    @method exit
    @private
    */
    itemCompletionCallback (...args) {
        // Store the first error
        let error = this.state.error
        if ( args[0] &amp;&amp; !error ) {
            this.state.error = error = args[0]
        }

        // Complete for the first (and hopefully only) time
        if ( this.completed === false ) {
            // Apply the result if it exists
            if ( args.length !== 0 ) this.state.result = args
        }

        // Finish up
        this.finish()

        // Chain
        return this
    }

    /**
    Set our task to the completed state.
    @chainable
    @method finish
    @private
    */
    finish () {
        const error = this.state.error

        // Complete for the first (and hopefully only) time
        if ( this.completed === false ) {
            // Set the status and emit depending on success or failure status
            const status = error ? &#x27;failed&#x27; : &#x27;passed&#x27;
            this.state.status = status
            this.emit(status, error)

            // Fire the completion callback
            this.complete()
        }

        // Error as we have already completed before
        else if ( this.config.onError !== &#x27;ignore&#x27; ) {
            const completedError = new Error(&#x60;The task [${this.names}] just completed, but it had already completed earlier, this is unexpected.&#x60;)
            this.emit(&#x27;error&#x27;, completedError)
        }

        // Chain
        return this
    }

    /**
    Allow the user to abort the execution of this task.
    @chainable
    @method abort
    @private
    @TODO figure out how this should actually work
    */
    abort (error) {
        // Not yet implemented
        if ( true ) {
            const error = new Error(&#x27;TaskGroup::abort has not yet been implemented.&#x27;)
            this.emit(&#x27;error&#x27;, error)
        }

        // Don&#x27;t allow aborting if we have already completed
        if ( this.completed ) {
            const error = new Error(&#x60;The task [${this.names}] cannot abort as the task has already completed, this is unexpected.&#x60;)
            this.emit(&#x27;error&#x27;, error)
        }
        else {
            // Update the error state if not yet set
            if ( error &amp;&amp; !this.state.error ) {
                this.state.error = error
            }

            // Finish up
            this.finish()
        }

        // Chain
        return this
    }

    /**
    Completetion Emitter. Used to emit the &#x60;completed&#x60; event and to cleanup our state.
    @chainable
    @method complete
    @private
    */
    complete () {
        const completed = this.completed
        if ( completed ) {
            // Notify our listeners we have completed
            const args = this.state.result || []
            this.emit(&#x27;completed&#x27;, ...args)

            // Prevent the error from persisting
            this.state.error = null

            // Should we reset results?
            // this.results = []
            // no, it would break the promise nature of done
            // as it would mean that if multiple done listener are added, they would each get different results
            // if they wish to reset the results, they should do so manually via resetResults

            // Should we reset the status?
            // this.status = null
            // no, it would break the promise nature of done
            // as it would mean that once a done is fired, no more can be fired, until run is called again
        }
        return completed
    }

    /**
    When Done Promise.
    Fires the listener, either on the next tick if we are already done, or if not, each time the &#x60;done&#x60; event fires.
    @param {Function} listener - The {Function} to attach or execute.
    @chainable
    @method whenDone
    @public
    */
    whenDone (listener) {
        if ( this.completed ) {
            // avoid zalgo
            this.queue(() =&gt; {
                const result = this.state.result || []
                listener.apply(this, result)
            })
        }
        else {
            super.whenDone(listener)
        }

        // Chain
        return this
    }

    /**
    Once Done Promise.
    Fires the listener once, either on the next tick if we are already done, or if not, each time the &#x60;done&#x60; event fires.
    @param {Function} listener - The {Function} to attach or execute.
    @chainable
    @method onceDone
    @public
    */
    onceDone (listener) {
        if ( this.completed ) {
            // avoid zalgo
            this.queue(() =&gt; {
                const result = this.state.result || []
                listener.apply(this, result)
            })
        }
        else {
            super.onceDone(listener)
        }

        // Chain
        return this
    }

    /**
    Reset the results.
    At this point this method is internal, as it&#x27;s functionality may change in the future, and it&#x27;s outside use is not yet confirmed. If you need such an ability, let us know via the issue tracker.
    @chainable
    @method resetResults
    @private
    */
    resetResults () {
        this.state.result = []
        return this
    }

    /**
    Clear the domain
    @chainable
    @method clearDomain
    @private
    */
    clearDomain () {
        const taskDomain = this.state.taskDomain
        if ( taskDomain ) {
            taskDomain.exit()
            taskDomain.removeAllListeners()
            this.state.taskDomain = null
        }
        return this
    }

    /**
    Destroy ourself and prevent ourself from executing ever again.
    @chainable
    @method destroy
    @public
    */
    destroy () {
        this.done(() =&gt; {
            // Prepare
            let status = this.state.status

            // Are we already destroyed?
            if ( status === &#x27;destroyed&#x27; )  return

            // Update our status and notify our listeners
            this.state.status = status = &#x27;destroyed&#x27;
            this.emit(status)

            // Clear results
            this.resetResults()
            // item arrays should already be wiped due to done completion

            // Remove all isteners
            // thisTODO should we exit or dispose of the domain?
            this.removeAllListeners()

            // Clear the domain
            this.clearDomain()
        })

        // Chain
        return this
    }

    /**
    Fire the task method with our config arguments and wrapped in a domain.
    @chainable
    @method fire
    @private
    */
    fire () {
        // Prepare
        const args = (this.config.args || []).slice()
        let taskDomain = this.state.taskDomain
        const useDomains = this.config.domain !== false
        const exitMethod = this.itemCompletionCallback.bind(this)
        let method = this.config.method

        // Check that we have a method to fire
        if ( !method ) {
            const error = new Error(&#x60;The task [${this.names}] failed to run as no method was defined for it.&#x60;)
            this.emit(&#x27;error&#x27;, error)
            return this
        }

        // Bind method
        method = method.bind(this)

        // Prepare the task domain if it doesn&#x27;t already exist
        if ( useDomains &amp;&amp; domain &amp;&amp; !taskDomain ) {
            // Setup the domain
            this.state.taskDomain = taskDomain = domain.create()
            taskDomain.on(&#x27;error&#x27;, exitMethod)
        }

        // Domains, as well as process.nextTick, make it so we can&#x27;t just use exitMethod directly
        // Instead we cover it up like so, to ensure the domain exits, as well to ensure the arguments are passed
        const completeMethod = (...args) =&gt; {
            if ( this.config.sync || taskDomain ) {
                this.clearDomain()
                taskDomain = null
                exitMethod(...args)
            }
            else {
                // Use the next tick workaround to escape the try...catch scope
                // Which would otherwise catch errors inside our code when it shouldn&#x27;t therefore suppressing errors
                // @TODO add test for this, originally used process.nextTick, changed to queue, hopefully it still does the same
                queue(function () {
                    exitMethod(...args)
                })
            }
        }

        // Our fire function that will be wrapped in a domain or executed directly
        const fireMethod = () =&gt; {
            // Execute with ambi if appropriate
            if ( this.config.ambi !== false ) {
                ambi(method, ...args)
            }

            // Otherwise execute directly if appropriate
            else {
                method(...args)
            }
        }

        // Add the competion callback to the arguments our method will receive
        args.push(completeMethod)

        // Setup timeout if appropriate
        const timeoutDuration = this.config.timeout
        if ( timeoutDuration ) {
            this.state.timeout = wait(timeoutDuration, () =&gt; {
                if ( !this.completed ) {
                    const error = new Error(&#x60;The task [${this.names}] has timed out.&#x60;)
                    exitMethod(error)
                }
            })
        }

        // Notify that we are now running
        const status = &#x27;running&#x27;
        this.state.status = status
        this.emit(status)

        // Fire the method within the domain if desired, otherwise execute directly
        if ( taskDomain ) {
            taskDomain.run(fireMethod)
        }
        else {
            try {
                fireMethod()
            }
            catch (error) {
                exitMethod(error)
            }
        }

        // Chain
        return this
    }

    /**
    Start the execution of the task.
    Will emit an &#x60;error&#x60; event if the task has already started before.
    @chainable
    @method run
    @public
    */
    run () {
        this.queue(() =&gt; {
            // Already completed or even destroyed?
            if ( this.started ) {
                const error = new Error(&#x60;The task [${this.names}] was just about to start, but it already started earlier, this is unexpected.&#x60;)
                this.emit(&#x27;error&#x27;, error)
            }

            // Not yet completed, so lets run!
            else {
                // Apply our new status and notify our listeners
                const status = &#x27;started&#x27;
                this.state.status = status
                this.emit(status)

                // Fire the task
                this.fire()
            }
        })

        // Chain
        return this
    }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
