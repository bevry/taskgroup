<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>esnext/lib/taskgroup.js - TaskGroup API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://localhost:8000/web/logo.svg" title="TaskGroup API"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 5.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/BaseInterface.html">BaseInterface</a></li>
                                <li><a href="../classes/Task.html">Task</a></li>
                                <li><a href="../classes/TaskGroup.html">TaskGroup</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: esnext/lib/taskgroup.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* eslint no-extra-parens:0 */
&#x27;use strict&#x27;

// Imports
const BaseInterface = require(&#x27;./interface&#x27;)
const Task = require(&#x27;./task&#x27;)
const {ensureArray, errorToString} = require(&#x27;./util&#x27;)
const extendr = require(&#x27;extendr&#x27;)
const eachr = require(&#x27;eachr&#x27;)

/**
Our TaskGroup class.

Available configuration is documented in {{#crossLink &quot;TaskGroup/setConfig&quot;}}{{/crossLink}}.

Available events:

- &#x60;started()&#x60; - emitted when we start execution
- &#x60;running()&#x60; - emitted when the first item starts execution
- &#x60;failed(error)&#x60; - emitted when execution exited with a failure
- &#x60;passed()&#x60; - emitted when execution exited with a success
- &#x60;completed(error, results)&#x60; - emitted when execution exited, &#x60;results&#x60; is an {Array} of the result arguments for each item that executed
- &#x60;error(error)&#x60; - emtited if an unexpected error occured within ourself
- &#x60;done(error, results)&#x60; - emitted when either the execution completes (the &#x60;completed&#x60; event) or when an unexpected error occurs (the &#x60;error&#x60; event)
- &#x60;item.*(...)&#x60; - bubbled events from an added item
- &#x60;task.*(...)&#x60; - bubbled events from an added {Task}
- &#x60;group.*(...)&#x60; - bubbled events from an added {TaskGroup}

Available internal statuses:

- &#x60;null&#x60; - execution has not yet started
- &#x60;&#x27;started&#x27;&#x60; - execution has begun
- &#x60;&#x27;running&#x27;&#x60; - execution of items has begun
- &#x60;&#x27;failed&#x27;&#x60; - execution has exited with failure status
- &#x60;&#x27;passed&#x27;&#x60; - execution has exited with success status
- &#x60;&#x27;destroyed&#x27;&#x60; - we&#x27;ve been destroyed and can no longer execute

@constructor
@class TaskGroup
@extends BaseInterface
@public
*/
class TaskGroup extends BaseInterface {
    /**
    The type of our class.

    Used for the purpose of duck typing
    which is needed when working with node virtual machines
    as instanceof will not work in those environments.

    @type String
    @property type
    @default &#x27;taskgroup&#x27;
    @private
    */
    get type () { return &#x27;taskgroup&#x27; }

    /**
    A helper method to check if the passed argument is an instanceof a {TaskGroup}.
    @param {TaskGroup} item - The possible instance of the {TaskGroup} that we want to check
    @return {Boolean} Whether or not the item is a {TaskGroup} instance.
    @method isTaskGroup
    @static
    @public
    */
    static isTaskGroup (group) {
        return group &amp;&amp; group.type === &#x27;taskgroup&#x27; || group instanceof this
    }

    /**
    A reference to the {Task} class for use in {::createTask} if we want to override it.
    @type Task
    @property Task
    @default Task
    @public
    */
    get Task () { return Task }

    /**
    A reference to the {TaskGroup} class for use in {::createGroup} if we want to override it.
    @type TaskGroup
    @property TaskGroup
    @default TaskGroup
    @public
    */
    get TaskGroup () { return TaskGroup }

    // -----------------------------------
    // Export API

    /**
    A reference to the {Task} class.
    @type Task
    @property Task
    @default Task
    @static
    @public
    */
    static get Task () { return Task }

    /**
    A reference to the {TaskGroup} class.
    @type TaskGroup
    @property TaskGroup
    @default TaskGroup
    @static
    @public
    */
    static get TaskGroup () { return TaskGroup }


    // -----------------------------------
    // @TODO Decide if the following is still needed

    /**
    The {config.concurrency} property.
    @type Number
    @property concurrency
    @protected
    */
    get concurrency () { return this.config.concurrency }

    /**
    The first {Error} that has occured.
    @type Error
    @property error
    @protected
    */
    get error () { return this.state.error }

    /**
    A {String} containing our current status. See our {TaskGroup} description for available values.
    @type String
    @property status
    @protected
    */
    get status () { return this.state.status }

    /**
    An {Array} of the events that we may emit. Events that will be executed can be found in the {Task} description.
    @type Array
    @property events
    @protected
    */
    get events () { return this.state.events }

    /**
    An {Array} that contains the result property for each completed {Task} and {TaskGroup}.
    An item can disable having its result property added to this results array by setting its {includeInResults} configuration option to &#x60;false&#x60;.
    @type Array
    @property results
    @protected
    */
    get results () { return this.state.results }

    /**
    An {Array} of each {Task} and {TaskGroup} in this group that are still yet to execute.
    @type Array
    @property itemsRemaining
    @protected
    */
    get itemsRemaining () { return this.state.itemsRemaining }

    /**
    An {Array} of each {Task} and {TaskGroup} in this group that are currently executing.
    @TODO offer the ability to disable this completely via &#x60;storeRunningItems: false&#x60;
    @type Array
    @property itemsRunning
    @protected
    */
    get itemsRunning () { return this.state.itemsRunning }

    /**
    An {Array} of each {Task} and {TaskGroup} in this group that have completed.
    @TODO offer the ability to disable this completely via &#x60;storeCompletedItems: false&#x60;
    @type Array
    @property itemsRunning
    @protected
    */
    get itemsCompleted () { return this.state.itemsCompleted }

    /**
    Initialize our new {TaskGroup} instance. Forwards arguments onto {{#crossLink &quot;TaskGroup/setConfig&quot;}}{{/crossLink}}.
    @method constructor
    @public
    */
    constructor (...args) {
        super()

        // State defaults
        extendr.defaults(this.state, {
            id: &#x60;${this.type} ${Math.random()}&#x60;,
            error: null,
            status: null,
            events: [&#x27;error&#x27;, &#x27;started&#x27;, &#x27;running&#x27;, &#x27;passed&#x27;, &#x27;failed&#x27;, &#x27;completed&#x27;, &#x27;done&#x27;, &#x27;destroyed&#x27;],
            results: [],
            itemsRemaining: [],
            itemsRunning: [],
            itemsCompleted: []
        })

        // Configuration defaults
        extendr.defaults(this.config, {
            // @TODO update storeCompleted to actually not store anything
            // this will require tests to be updated (as task names no longer will be stored)
            // as well as a counter inserted for the total completed (we may even get rid of that)
            storeCompleted: false,
            // @TODO implement one or both of the following to ensure taskgroups successfully die once completed
            //   should also implement this for the task class too
            // storeResults: false,
            // onExit: &#x27;destroy&#x27;,
            nestedEvents: false,
            nestedTaskConfig: {},
            nestedGroupConfig: {},
            concurrency: 1,
            onError: &#x27;exit&#x27;,
            sync: false
        })

        // Apply user configuration
        this.setConfig(...args)

        // Give setConfig enough chance to fire
        // Changing this to setImmediate breaks a lot of things
        // As tasks inside nested taskgroups will fire in any order
        this.queue(this.autoRun.bind(this))
    }


    // ---------------------------------
    // Configuration

    /**
    Merged passed configuration into {config.nestedTaskConfig}.
    @param {Object} opts - The configuration to merge.
    @chainable
    @method setNestedTaskConfig
    @public
    */
    setNestedTaskConfig (opts) {
        // Fetch and copy options to the state&#x27;s nested task configuration
        extendr.deep(this.state.nestedTaskConfig, opts)

        // Chain
        return this
    }

    /**
    Merged passed configuration into {config.nestedGroupConfig}.
    @param {Object} opts - The configuration to merge.
    @chainable
    @method setNestedGroupConfig
    @public
    */
    setNestedGroupConfig (opts) {
        // Fetch and copy options to the state&#x27;s nested configuration
        extendr.deep(this.state.nestedGroupConfig, opts)

        // Chain
        return this
    }

    /**
    Set the configuration for our instance.

    Despite accepting an {Object} of configuration, we can also accept an {Array} of configuration.    When using an array, a {String} becomes the :name, a {Function} becomes the :method, and an {Object} becomes the :config

    @param {Object} [config]

    @param {String} [config.name] - What we would like our name to be, useful for debugging.
    @param {Function} [config.done] - Passed to {{#crossLink &quot;TaskGroup/onceDone&quot;}}{{/crossLink}} (aliases are &#x60;onceDone&#x60;, and &#x60;next&#x60;)
    @param {Function} [config.whenDone] - Passed to {{#crossLink &quot;TaskGroup/whenDone&quot;}}{{/crossLink}}
    @param {Object} [config.on] - An object of event names linking to listener functions that we would like bounded via {EventEmitter.on}.
    @param {Object} [config.once] - An object of event names linking to listener functions that we would like bounded via {EventEmitter.once}.
    @param {TaskGroup} [config.parent] - A parent {{#crossLink &quot;TaskGroup&quot;}}{{/crossLink}} that we may be attached to.
    @param {String} [config.onError] - Either &#x60;&#x27;exit&#x27;&#x60; or &#x60;&#x27;ignore&#x27;&#x60;, when &#x60;&#x27;ignore&#x27;&#x60; duplicate run errors are not reported, useful when combined with the timeout option.
    @param {Boolean} [config.sync=false] - Whether or not we should execute certain calls asynchronously (set to &#x60;false&#x60;) or synchronously (set to &#x60;true&#x60;).

    @param {Function} [config.method] - The {Function} to execute for our {TaskGroup} when using inline execution style.
    @param {Boolean} [config.run=true] - A {Boolean} for whether or not to the :method (if specified) automatically.
    @param {Number} [config.concurrency=1] - The amount of items that we would like to execute at the same time. Use &#x60;0&#x60; for unlimited. &#x60;1&#x60; accomplishes serial execution, everything else accomplishes parallel execution.
    @param {Object} [config.nestedGroupConfig] - The nested configuration to be applied to all {TaskGroup} descendants of this group.
    @param {Object} [config.nestedTaskConfig] - The nested configuration to be applied to all {Task} descendants of this group.
    @param {Array} [config.tasks] - An {Array} of {Task} instances to be added to this group.
    @param {Array} [config.groups] - An {Array} of {TaskGroup} instances to be added to this group.
    @param {Array} [config.items] - An {Array} of {Task} and/or {TaskGroup} instances to be added to this group.

    @chainable
    @method setConfig
    @public
    */
    setConfig (...args) {
        const opts = {}

        // Extract the configuration from the arguments
        args.forEach(function (arg) {
            if ( arg == null )  return
            const type = typeof arg
            switch ( type ) {
                case &#x27;string&#x27;:
                    opts.name = arg
                    break
                case &#x27;function&#x27;:
                    opts.method = arg
                    break
                case &#x27;object&#x27;:
                    extendr.deep(opts, arg)
                    break
                default:
                    const error = new Error(&#x60;Unknown argument type of [${type}] given to TaskGroup::setConfig()&#x60;)
                    throw error
            }
        })

        // Apply the configuration directly to our instance
        eachr(opts, (value, key) =&gt; {
            if ( value == null )  return
            switch ( key ) {
                case &#x27;on&#x27;:
                    eachr(value, (value, key) =&gt; {
                        if ( value )  this.on(key, value)
                    })
                    break

                case &#x27;once&#x27;:
                    eachr(value, (value, key) =&gt; {
                        if ( value )  this.once(key, value)
                    })
                    break

                case &#x27;whenDone&#x27;:
                    this.whenDone(value)
                    break

                case &#x27;onceDone&#x27;:
                case &#x27;done&#x27;:
                case &#x27;next&#x27;:
                    this.done(value)
                    break

                case &#x27;task&#x27;:
                case &#x27;tasks&#x27;:
                    this.addTasks(value)
                    break

                case &#x27;group&#x27;:
                case &#x27;groups&#x27;:
                    this.addGroups(value)
                    break

                case &#x27;item&#x27;:
                case &#x27;items&#x27;:
                    this.addItems(value)
                    break

                default:
                    this.config[key] = value
                    break
            }
        })

        // Chain
        return this
    }


    // ---------------------------------
    // TaskGroup Method

    /**
    Prepare the method and it&#x27;s configuration, and add it as a task to be executed.
    @param {Function} method - The function we want to execute as the method of this TaskGroup.
    @param {Object} config - Optional configuration for the task to be created for the method.
    @return {Task} The task for the method.
    @method addMethod
    @private
    */
    addMethod (method, opts = {}) {
        method = method.bind(this) // run the taskgroup method on the group, rather than itself
        method.isTaskGroupMethod = true
        if ( !opts.name )  opts.name = &#x27;taskgroup method for &#x27; + this.name
        if ( !opts.args )  opts.args = [this.addGroup.bind(this), this.addTask.bind(this)]
        if ( opts.includeInResults == null )  opts.includeInResults = false
        return this.addTask(method, opts)
    }

    /**
    Autorun ourself under certain conditions.

    Those conditions being:

    - if we the :method configuration is defined, and we have no :parent
    - if we the :run configuration is &#x60;true&#x60;

    Used primarily to cause the :method to fire at the appropriate time when using inline style.

    @chainable
    @method autoRun
    @private
    */
    autoRun () {
        // Prepare
        const method = this.config.method
        let run = this.config.run

        // Auto run if we are going the inline style and have no parent
        if ( method ) {
            // Add the function as our first unamed task with the extra arguments
            this.addMethod(method)

            // If we are the topmost group default run to true
            if ( !this.config.parent &amp;&amp; run == null ) {
                this.state.run = run = true
            }
        }

        // Auto run if we are configured to
        if ( run ) {
            this.run()
        }

        // Chain
        return this
    }


    // ---------------------------------
    // Add Item

    /**
    Adds a {Task|TaskGroup} instance and configures it from the arguments.

    @param {Arguments} ...args - Arguments used to configure the {Task|TaskGroup} instance.

    @return {Task|TaskGroup}
    @method addItem
    @public
    */
    addItem (item, ...args) {
        // Prepare
        const me = this

        // Only add the item if it exists
        if ( !item ) return null

        // Link our item to ourself
        const itemConfig = {
            parent: this,
            sync: this.config.sync
        }

        // Extract
        const nestedGroupConfig = this.config.nestedGroupConfig
        const nestedTaskConfig = this.config.nestedTaskConfig
        const nestedEvents = this.config.nestedEvents

        // Bubble task events
        if ( Task.isTask(item) ) {
            // Nested configuration
            item.setConfig(itemConfig, nestedTaskConfig, ...args)

            // Bubble the nested events if desired
            if ( nestedEvents ) {
                item.state.events.forEach(function (event) {
                    item.on(event, function (...args) {
                        me.emit(&#x60;task.${event}&#x60;, item, ...args)
                    })
                })
            }

            // Notify our intention
            this.emit(&#x27;task.add&#x27;, item)
        }

        // Bubble group events
        else if ( TaskGroup.isTaskGroup(item) ) {
            // Nested configuration
            item.setConfig(itemConfig, {nestedTaskConfig, nestedGroupConfig}, nestedGroupConfig, ...args)

            // Bubble the nested events if desired
            if ( nestedEvents ) {
                item.state.events.forEach(function (event) {
                    item.on(event, function (...args) {
                        me.emit(&#x60;group.${event}&#x60;, item, ...args)
                    })
                })
            }

            // Notify our intention
            this.emit(&#x27;group.add&#x27;, item)
        }

        // Unknown type
        else {
            let error = new Error(&#x27;Unknown item type&#x27;)
            this.emit(&#x27;error&#x27;, error)
            return this
        }

        // Name default
        if ( !item.config.name ) {
            item.config.name = &#x60;${item.type} ${this.totalItems + 1} for [${this.name}]&#x60;
        }

        // Bubble the nested events if desired
        if ( nestedEvents ) {
            item.state.events.forEach(function (event) {
                item.on(event, function (...args) {
                    me.emit(&#x60;item.${event}&#x60;, item, ...args)
                })
            })
        }

        // Emit
        this.emit(&#x27;item.add&#x27;, item)

        // Handle item completion and errors once
        // we can&#x27;t just do item.done, or item.once(&#x27;done&#x27;), because we need the item to be the argument, rather than &#x60;this&#x60;
        item.done(function (...args) {
            me.itemCompletionCallback(item, ...args)
        })

        // Add the item
        this.state.itemsRemaining.push(item)

        // We may be running and expecting items, if so, fire
        this.fire()

        // Return the item
        return item
    }

    /**
    Adds {Task|TaskGroup} instances and configures them from the arguments.

    @param {Array} items - Array of {Task|TaskGroup} instances to add to this task group.
    @param {Arguments} ...args - Arguments used to configure the {Task|TaskGroup} instances.

    @return {Array}
    @method addItems
    @public
    */
    addItems (items, ...args) {
        items = ensureArray(items)
        items.map((item) =&gt; this.addItem(item, ...args))
        return items
    }

    /**
    Same as {{#crossLink &quot;TaskGroup/addItem&quot;}}{{/crossLink}} but chains instead of returning the item.
    @chainable
    @method addItemChain
    @public
    */
    addItemChain (...args) {
        this.addItem(...args)
        return this
    }

    /**
    Same as {{#crossLink &quot;TaskGroup/addItems&quot;}}{{/crossLink}} but chains instead of returning the item.
    @chainable
    @method addItemsChain
    @public
    */
    addItemsChain (...args) {
        this.addItems(...args)
        return this
    }


    // ---------------------------------
    // Add Task

    /**
    Creates a {Task} instance and configures it from the arguments.

    If the first argument is already a {Task} instance, then we configure it with the remaining arguments, instead of creating a new {Task} instance.

    @param {Arguments} ...args - Arguments used to configure the {Task} instance.

    @return {Task}
    @method createTask
    @public
    */
    createTask (...args) {
        // Prepare
        let task

        // Support receiving an existing task instance
        if ( Task.isTask(args[0]) ) {
            task = args[0]
            task.setConfig(...args.slice(1))
        }

        // Support receiving arguments to create a task instance
        else {
            task = new this.Task(...args)
        }

        // Return the new task
        return task
    }

    /**
    Adds a {Task} instance and configures it from the arguments.

    If a {Task} instance is not supplied, a {Task} instance is created from the arguments.

    @param {Arguments} ...args - Arguments used to configure the {Task} instance.

    @return {Task}
    @method addTask
    @public
    */
    addTask (...args) {
        const task = this.createTask(...args)
        return this.addItem(task)
    }

    /**
    Adds {Task} instances and configures them from the arguments.

    @param {Array} items - Array of {Task} instances to add to this task group.
    @param {Arguments} ...args - Arguments used to configure the {Task} instances.

    @return {Array}
    @method addTask
    @public
    */
    addTasks (items, ...args) {
        items = ensureArray(items)
        items.map((item) =&gt; this.addTask(item, ...args))
        return items
    }

    /**
    Same as {{#crossLink &quot;TaskGroup/addTask&quot;}}{{/crossLink}} but chains instead of returning the item.
    @chainable
    @method addTaskChain
    @public
    */
    addTaskChain (...args) {
        this.addTask(...args)
        return this
    }

    /**
    Same as {{#crossLink &quot;TaskGroup/addTasks&quot;}}{{/crossLink}} but chains instead of returning the item.
    @chainable
    @method addTasksChain
    @public
    */
    addTasksChain (...args) {
        this.addTasks(...args)
        return this
    }


    // ---------------------------------
    // Add Group

    /**
    Creates a {TaskGroup} instance and configures it from the arguments.

    If the first argument is already a {TaskGroup} instance, then we configure it with the remaining arguments, instead of creating a new {TaskGroup} instance.

    @param {Arguments} ...args - Arguments used to configure the {TaskGroup} instance.

    @return {TaskGroup}
    @method createGroup
    @public
    */
    createGroup (...args) {
        // Prepare
        let group

        // Support receiving an existing group instance
        if ( TaskGroup.isTaskGroup(args[0]) ) {
            group = args[0]
            group.setConfig(...args.slice(1))
        }

        // Support receiving arguments to create a group instance
        else {
            group = new this.TaskGroup(...args)
        }

        // Return the new group
        return group
    }

    /**
    Adds a {TaskGroup} instance and configures it from the arguments.

    If a {TaskGroup} instance is not supplied, a {TaskGroup} instance is created from the arguments.

    @param {Arguments} ...args - Arguments used to configure the {TaskGroup} instance.

    @return {TaskGroup}
    @method addGroup
    @public
    */
    addGroup (...args) {
        const group = this.createGroup(...args)
        return this.addItem(group)
    }

    /**
    Adds {TaskGroup} instances and configures them from the arguments.

    @param {Array} items - Array of {TaskGroup} instances to add to this task group.
    @param {Arguments} ...args - Arguments used to configure the {TaskGroup} instances.

    @return {Array}
    @method addGroups
    @public
    */
    addGroups (items, ...args) {
        items = ensureArray(items)
        items.map((item) =&gt; this.addGroup(item, ...args))
        return items
    }

    /**
    Same as {{#crossLink &quot;TaskGroup/addGroup&quot;}}{{/crossLink}} but chains instead of returning the item.
    @chainable
    @method addGroupChain
    @public
    */
    addGroupChain (...args) {
        this.addGroup(...args)
        return this
    }

    /**
    Same as {{#crossLink &quot;TaskGroup/addGroups&quot;}}{{/crossLink}} but chains instead of returning the item.
    @chainable
    @method addGroupsChain
    @public
    */
    addGroupsChain (...args) {
        this.addGroups(...args)
        return this
    }


    // ---------------------------------
    // Status Indicators

    /**
    Gets the total number of items inside our task group.
    @type Number
    @property totalItems
    @public
    */
    get totalItems () {
        const running = this.state.itemsRunning.length
        const remaining = this.state.itemsRemaining.length
        const completed = this.state.itemsCompleted.length
        const total = running + remaining + completed
        return total
    }

    /**
    Gets the total number count of each of our item lists.

    Returns an {Object} containg the hashes:

    - remaining - A {Number} of the names of the remaining items.
    - running - A {Number} of the names of the running items.
    - completed - A {Number} of the names of the completed items.
    - total - A {Number} of the total items we have.
    - results - A {Number} of the total results we have.

    @type Object
    @property itemTotals
    @public
    */
    get itemTotals () {
        const running = this.state.itemsRunning.length
        const remaining = this.state.itemsRemaining.length
        const completed = this.state.itemsCompleted.length
        const results = this.state.results.length
        const total = running + remaining + completed
        return {
            remaining,
            running,
            completed,
            total,
            results
        }
    }

    /**
    Gets the names of the items, the total number of items, and their results for the purpose of debugging.

    Returns an {Object} containg the hashes:

    - remaining - An {Array} of the names of the remaining items
    - running - An {Array} of the names of the running items
    - completed - An {Array} of the names of the completed items
    - total - A {Number} of the total items we have
    - results - An {Array} of the results of the compelted items

    @type Object
    @property itemNames
    @protected
    */
    get itemNames () {
        const running = this.state.itemsRunning.map((item) =&gt; item.name)
        const remaining = this.state.itemsRemaining.map((item) =&gt; item.name)
        const completed = this.state.itemsCompleted.map((item) =&gt; item.name || item)
        const results = this.state.results
        const total = running.length + remaining.length + completed.length
        return {
            remaining,
            running,
            completed,
            total,
            results
        }
    }

    /**
    Whether or not we have any running items.
    @type Boolean
    @property hasRunning
    @private
    */
    get hasRunning () {
        return this.state.itemsRunning.length !== 0
    }

    /**
    Whether or not we have any items yet to execute.
    @type Boolean
    @property hasRunning
    @private
    */
    get hasRemaining () {
        return this.state.itemsRemaining.length !== 0
    }

    /**
    Whether or not we have any items running or remaining.
    @type Boolean
    @property hasItems
    @private
    */
    get hasItems () {
        return this.hasRunning || this.hasRemaining
    }

    /**
    Whether or not we have an error.
    @type Boolean
    @property hasError
    @private
    */
    get hasError () {
        return this.state.error != null
    }

    /**
    Whether or not we have an error or a result.
    @type Boolean
    @property hasResult
    @private
    */
    get hasResult () {
        return this.hasError || this.state.results.length !== 0
    }

    /**
    Whether or not we have any available slots to execute more items.
    @type Boolean
    @property hasResult
    @private
    */
    get hasSlots () {
        const concurrency = this.config.concurrency
        return concurrency === 0 || this.state.itemsRunning.length &lt; concurrency
    }

    /**
    Whether or not we are capable of firing more items.

    This is determined whether or not we are not paused, and we have remaning items, and we have slots able to execute those remaning items.

    @type Boolean
    @property shouldFire
    @private
    */
    get shouldFire () {
        return (
            !this.shouldPause &amp;&amp;
            this.hasRemaining &amp;&amp;
            this.hasSlots
        )
    }

    /**
    Whether or not we have errord and want to pause when we have an error.
    @type Boolean
    @property shouldPause
    @private
    */
    get shouldPause () {
        return (
            this.config.onError === &#x27;exit&#x27; &amp;&amp; this.hasError
        )
    }

    /**
    Whether or not we execution is currently paused.
    @type Boolean
    @property paused
    @private
    */
    get paused () {
        return (
            this.shouldPause &amp;&amp;
            !this.hasRunning
        )
    }

    /**
    Whether or not we have no running or remaining items left.
    @type Boolean
    @property empty
    @private
    */
    get empty () {
        return !this.hasItems
    }

    /**
    Whether or not we have finished execution.
    @type Boolean
    @property exited
    @private
    */
    get exited () {
        switch ( this.state.status ) {
            case &#x27;completed&#x27;:
            case &#x27;destroyed&#x27;:
                return true

            default:
                return false
        }
    }

    /**
    Whether or not we have started execution.
    @type Boolean
    @property started
    @private
    */
    get started () {
        return this.state.status != null
    }

    /**
    Whether or not we execution has completed.

    Completion of executed is determined of whether or not we have started, and whether or not we are currently paused or have no remaining and running items left

    @type Boolean
    @property completed
    @private
    */
    get completed () {
        return (
            this.started &amp;&amp;
            (
                this.paused ||
                this.empty
            )
        )
    }


    // ---------------------------------
    // Firers

    /**
    Completetion Emitter. Used to emit the &#x60;completed&#x60; event and to cleanup our state.
    @chainable
    @method complete
    @private
    */
    complete () {
        const completed = this.completed

        if ( completed ) {
            // Notity our listners we have completed
            this.emit(&#x27;completed&#x27;, this.state.error, this.state.results)

            // Prevent the error from persisting
            this.state.error = null

            // Clear and destroy completed
            this.clearCompleted()

            // Should we reset results?
            // this.state.results = []
            // no, it would break the promise nature of done
            // as it would mean that if multiple done handlers are added, they would each get different results
            // if they wish to reset the results, they should do so manually via resetResults

            // Should we reset the status?
            // this.state.status = null
            // no, it would break the promise nature of done
            // as it would mean that once a done is fired, no more can be fired, until run is called again
        }

        return completed
    }

    /**
    When Done Promise.
    Fires the listener, either on the next tick if we are already done, or if not, each time the &#x60;done&#x60; event fires.
    @param {Function} listener - The {Function} to attach or execute.
    @chainable
    @method whenDone
    @public
    */
    whenDone (handler) {
        if ( this.completed ) {
            // avoid zalgo
            this.queue( () =&gt; handler.call(this, this.state.error, this.state.results) )
        }
        else {
            super.whenDone(handler)
        }

        // Chain
        return this
    }

    /**
    Once Done Promise.
    Fires the listener once, either on the next tick if we are already done, or if not, each time the &#x60;done&#x60; event fires.
    @param {Function} listener - The {Function} to attach or execute.
    @chainable
    @method onceDone
    @public
    */
    onceDone (handler) {
        if ( this.completed ) {
            // avoid zalgo
            this.queue( () =&gt; handler.call(this, this.state.error, this.state.results) )
        }
        else {
            super.onceDone(handler)
        }

        // Chain
        return this
    }

    /**
    Reset the results.
    At this point this method is internal, as it&#x27;s functionality may change in the future, and it&#x27;s outside use is not yet confirmed. If you need such an ability, let us know via the issue tracker.
    @chainable
    @method resetResults
    @private
    */
    resetResults () {
        this.state.results = []

        // Chain
        return this
    }

    /**
    Fire the next items.
    @return {Array|false} Either an {Array} of items that were fired or &#x60;false&#x60; if no items were fired.
    @method fireNextItems
    @private
    */
    fireNextItems () {
        // Prepare
        const items = []

        // Fire the next items
        while ( true ) {
            const item = this.fireNextItem()
            if ( item ) {
                items.push(item)
            }
            else {
                break
            }
        }

        // Return the items or false if no items
        const result = items.length !== 0 ? items : false
        return result
    }

    /**
    Fire the next item.
    @return {Task|TaskGroup|false} Either the {Task|TaskGroup} item that was fired or &#x60;false&#x60; if no item was fired.
    @method fireNextItem
    @private
    */
    fireNextItem () {
        // Prepare
        let result = false

        // Can we run the next item?
        if ( this.shouldFire ) {
            // Fire the next item

            // Update our status and notify our listeners
            let status = this.state.status
            if ( status !== &#x27;running&#x27; ) {
                this.state.status = status = &#x27;running&#x27;
                this.emit(status)
            }

            // Get the next item
            const item = this.state.itemsRemaining.shift()

            // Add it to the remaining items
            this.state.itemsRunning.push(item)

            // Run it
            item.run()

            // Return the item
            result = item
        }

        // Return
        return result
    }

    /**
    What to do when an item completes.
    @chainable
    @param {Task|TaskGroup} item - The item that has completed
    @param {Arguments} ...args - The arguments that the item completed with.
    @method itemCompletionCallback
    @private
    */
    itemCompletionCallback (item, ...args) {
        // Prepare
        let error = this.state.error
        const itemsRunning = this.state.itemsRunning
        const itemsCompleted = this.state.itemsCompleted
        const results = this.state.results

        // Update error if it exists
        if ( this.config.onError === &#x27;exit&#x27; &amp;&amp; args[0] ) {
            if ( !error ) {
                this.state.error = error = args[0]
            }
        }

        // Mark that one less item is running
        const index = itemsRunning.indexOf(item)
        if ( index === -1 ) {
            // this should never happen, but maybe it could, in which case we definitely want to know about it
            const indexError = new Error(&#x60;Could not find [${item.names}] in the running queue&#x60;)
            /* eslint no-console:0 */
            console.error(errorToString(indexError))
            if ( !error ) {
                this.state.error = error = indexError
            }
        }
        else {
            itemsRunning.splice(index, 1)
        }

        // Add to the completed queue
        if ( this.config.storeCompleted ) {
            itemsCompleted.push(item)
        }
        else {
            // As it will no longer be destroyed in the complete() handler, destroy it here
            item.destroy()

            // Push the item name rather than the entire item, so that our itemsCompleted will have a low footprint
            itemsCompleted.push(item.name)
        }

        // Add the result
        if ( item.config.includeInResults !== false ) {
            results.push(args)
        }

        // Fire
        this.fire()

        // Chain
        return this
    }

    /**
    Internal: Either execute the reamining items we are not paused, or complete execution by exiting.
    @chainable
    @method fire
    @private
    */
    fire () {
        // Have we actually started?
        if ( this.started ) {
            // Check if we are complete, if so, exit
            if ( this.completed ) {
                // Finish up
                this.finish()
            }

            // Otherwise continue firing items if we are wanting to pause
            else if ( !this.shouldPause ) {
                this.fireNextItems()
            }
        }

        // Chain
        return this
    }

    /**
    Remove and destroy the remaining items.
    @chainable
    @method clearRemaining
    @public
    */
    clearRemaining () {
        const itemsRemaining = this.state.itemsRemaining
        while ( itemsRemaining.length !== 0 ) {
            itemsRemaining.pop().destroy()
        }

        // Chain
        return this
    }

    /**
    Remove and destroy the running items. Here for verboseness.
    @chainable
    @method clearRunning
    @private
    */
    clearRunning () {
        const error = new Error(&#x27;Clearing running items is not possible. Instead remaining items and wait for running items to complete.&#x27;)
        this.emit(&#x27;error&#x27;, error)
    }

    /**
    Remove and destroy the completed items.
    @chainable
    @method clearCompleted
    @public
    */
    clearCompleted () {
        const itemsCompleted = this.state.itemsCompleted
        if ( this.config.storeCompleted ) {
            while ( itemsCompleted.length !== 0 ) {
                itemsCompleted.pop().destroy()
            }
        }
        else {
            // jscs:disable disallowEmptyBlocks
            while ( itemsCompleted.pop() ) { }
            // jscs:enable requireCurlyBraces
        }

        // Chain
        return this
    }

    /**
    Destroy ourself and prevent ourself from executing ever again.
    @chainable
    @method destroy
    @public
    */
    destroy () {
        // Clear remaining items to prevent them from running
        this.clearRemaining()

        // Once running items have finished, then proceed to destruction
        this.done(() =&gt; {
            // Prepare
            let status = this.state.status

            // Are we already destroyed?
            if ( status === &#x27;destroyed&#x27; ) return

            // We don&#x27;t need to call clear completed items as done() will have done that for us

            // Update our status and notify our listeners
            this.state.status = status = &#x27;destroyed&#x27;
            this.emit(status)

            // Clear results
            this.resetResults()
            // item arrays should already be wiped due to done completion

            // Remove listeners
            this.removeAllListeners()
        })

        // Chain
        return this
    }

    /**
    Set our task to the completed state.
    @NOTE This doesn&#x27;t have to be a separate method, it could just go inside &#x60;fire&#x60; however, it is nice to have here to keep &#x60;fire&#x60; simple
    @chainable
    @method finish
    @private
    */
    finish () {
        // Set and emmit the appropriate status for our error or non-error
        const error = this.state.error
        const status = error ? &#x27;failed&#x27; : &#x27;passed&#x27;
        this.state.status = status
        this.emit(status, error)

        // Fire the completion callback
        this.complete()
    }

    /**
    We want to halt execution and trigger our completion callback.

    @TODO figure out how this should actually work?
    Should it be two methods? .halt() and .abort(error?)
    Should it be a state?
    Should it alter the state?
    Should it clear or destroy?
    What is the definition of pausing with this?
    Perhaps we need to update the definition of pausing to be halted instead?
    How can we apply this to Tasks instead?

    @param {Error} error - An optional error to provide if not already set.
    @chainable
    @method abort
    @private
    */
    abort (error) {
        // This method is not yet implemented
        if ( true ) {
            const error = new Error(&#x27;TaskGroup::abort has not yet been implemented.&#x27;)
            this.emit(&#x27;error&#x27;, error)
        }

        // Update the error state if not yet set
        if ( error &amp;&amp; !this.state.error ) {
            this.state.error = error
        }

        // Finish up
        // ...

        // Chain
        return this
    }

    /**
    Start/restart/resume the execution of the TaskGroup.
    @chainable
    @method run
    @public
    */
    run () {
        this.queue(() =&gt; {
            // Already destroyed?
            if ( this.state.status === &#x27;destroyed&#x27; ) {
                const error = new Error(&#x60;The taskgroup [${this.names}] was just about to start, but it was destroyed earlier, this is unexpected.&#x60;)
                this.emit(&#x27;error&#x27;, error)
            }

            // Apply our new status and notify our intention to run
            const status = &#x27;started&#x27;
            this.state.status = status
            this.emit(status)

            // Give time for the listeners to complete before continuing
            this.fire()
        })

        // Chain
        return this
    }
}

// Export
module.exports = TaskGroup

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
